
#ifndef LIBFT_H
# define LIBFT_H

# include <stdlib.h>
# include <unistd.h>

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;

// part 1

size_t				ft_strlcpy(char *dst, const char *src, size_t dstsize);
/* Функция strlcpy копирует из строки src в буфер dst не более чем size - 
1 символов и гарантированно устанавливает в конец строки нулевой символ */

size_t				ft_strlcat(char *dst, const char *src, size_t size);
/* Функция strlcpy копирует из строки src в буфер dst не более чем size - 
1 символов начиная с последнего симваола в dst и гарантированно 
устанавливает в конец строки нулевой символ*/

size_t				ft_strlen(const char *s);
/* Функция strlen вычисляет количество символов в строке до первого 
вхождения символа конца строки */

int					ft_atoi(const char *str);
/* приводит в строку в числовой вид выводя первые числа если перед ними 
нет иных симвлолв, учитывая отрицательные и положительные значения */

int					ft_isalpha(int c);
/* проверяет аргумент, передаваемый через параметр сharacter, является
 ли он строчной или прописной буквой алфавита. */

int					ft_isdigit(int c);
/* проверяет аргумент, передаваемый через параметр сharacter, является 
ли он десятичной цифрой */

int					ft_isalnum(int c);
/*проверяет параметр сharacter, через который передается целочисленное 
значение — эквивалент символа, является  ли сharacter десятичной цифрой
 или символом алфавита, прописной или строчной буквой. */

int					ft_isascii(int c);
/* проверяет параметр сharacter, через который передается целочисленное 
значение — на принадлежность к занчениям таблицы ascii.*/

int					ft_isprint(int c);
/* проверяет параметр сharacter, через который передается целочисленное 
значение — на принадлежность к печатаемым занчениям таблицы ascii*/

int					ft_toupper(int c);
/* переводит алфавит в верхний регистр */

int					ft_tolower(int c);
/* переводит алфавит в нижний регистр*/

int					ft_memcmp(const void *s1, const void *s2, size_t n);
/* сравнивает первые num байтов блока памяти указателя memptr1 с первыми 
num байтами блока памяти memptr2 по блокам */

int					ft_strncmp(const char *s1, const char *s2, size_t n);
/* сравнивает первые num символов строки string1 с первыми num символами 
строки string2. Эта функция начинает сравнивать первый символ каждой строки.
Если они равны, strncmp продолжает сравнивать  следующие пары символов, 
пока не будут найдены различные символы или пока не будет достигнут конец 
строки*/

char				*ft_strdup(const char *s);
/* создающая копию указанной нуль-терминированной строки в куче (используя 
malloc) и возвращающая указатель на неё.*/

char				*ft_strchr(const char *s, int c);
/* выполняет поиск первого вхождения символа symbol в строку string. 
Возвращает указатель на первое вхождение символа в строке. Завершающий
нулевой символ считается частью Си-строки. Таким образом, он также может
быть найден для получения указателя на конец строки */

char				*ft_strrchr(const char *s, int c);
/* ищет последнее вхождение символа symbol в строку string. Возвращает 
указатель на последнее вхождение символа в строке string. Завершающий 
нулевой символ считается частью строки. Таким образом, он также может 
быть найден для получения указателя на конец строки.*/

char				*ft_strnstr(const char *haystack, const char *needle,
						size_t len);
/* ищет первое вхождение len символов строки (за исключением признак конца
строки), на которую указывает аргумент needle, в строку , на которую 
указывает аргумент haystack. Если строка needle имеет нулевую длину, то 
функция вернет указатель на начало строки haystack.*/

void				*ft_calloc(size_t count, size_t size);
/* выделяет блок памяти для массива размером — num элементов, каждый из 
которых занимает   size байт, и инициализирует все свои биты в нулями.*/

void				ft_bzero(void *s, size_t n);
/* заполняет 0 все n символов в строке s от начала */

void				*ft_memcpy(void *dst, const void *src, size_t n);
/* копирует num байтов первого блока памяти, на который ссылается указатель
 srcptr, во второй блок памяти, на который ссылается указатель destptr*/

void				*ft_memset(void *s, int c, size_t len);
/* заполняет len байтов блока памяти, через указатель s. Код
заполняемого символа передаётся в функцию через параметр c */

void				*ft_memmove(void *dst, const void *src, size_t len);
/* копирует num байтов из блока памяти источника, на который ссылается
указатель srcptr, в блок памяти назначения, на который указывает
указатель destptr. Копирование происходит через промежуточный буфер,
что, в свою очередь, не позволяет destination и srcptr пересекаться*/

void				*ft_memchr(const void *s, int c, size_t n);
/* memchr в n байтах блока памяти, адресуемого указателем s, ищет 
первое вхождение c (интерпретируется как не подписанный символ), и 
возвращает указатель на найденный символ.*/

// part 2

char				*ft_substr(char const *s, unsigned int start, size_t len);
/* Возвращает подстроку строки string, начинающейся с start символа по счету
 и длиной length символов */

char				*ft_strjoin(char const *s1, char const *s2);
/* Сцепляет элементы указанных массивов или элементы коллекций, 
помещая между ними заданный разделитель.*/

char				*ft_strtrim(char const *s1, char const *set);
/* удаляет начальный и/или конечный пробел из входной строки */

char				**ft_split(char const *s, char c);
/* принимает массив и разделяет на массивы слова разделеные пробелами */

char				*ft_itoa(int n);
/* Выделяет (с помощью malloc(3)) и возвращает строкупредставляющую целое
число, полученное в качестве аргумента.Отрицательные числа должны быть
обработаны. */

char				*ft_strmapi(char const *s, char (*f)(unsigned int, char));
/* применяет функцию f к каждому символу строки s, переданной в качестве 
аргумента, указав ее индекс в качестве первого аргумента, чтобы создать 
«свежую» новую строку (с malloc), полученную в результате последовательного 
применения f.*/

void				ft_putchar_fd(char c, int fd);
/* Функция ft_putchar_fd выводит символ c в файловый дискриптор fd.*/

void				ft_putstr_fd(char *s, int fd);
/* Функция ft_putstr_fd выводит строку s в файловый дискриптор fd */

void				ft_putendl_fd(char *s, int fd);
/* Функция ft_putendl_fd выводит строку s с символом переноса строки \n 
в файловый дискриптор fd*/

void				ft_putnbr_fd(int n, int fd);
/* выводит число n в файловый дискриптор fd */

void				ft_striteri(char *s, void (*f)(unsigned int, char *));
/* применяет функцию f к каждому символу строки s, переданной в качестве 
аргумента, и передав ее индекс в качестве первого аргумента. Каждый символ 
передается по адресу f для изменения, если это необходимо.*/

// bonus

int					ft_lstsize(t_list *lst);
/* */

t_list				*ft_lstnew(void *content);
/* распределяет (с помощью malloc) и возвращает «новый» указатель на лист. 
Переменные content и content_size нового указателя инициализируются копией 
параметров функции. Если параметр имеет значение nul, содержимое переменной 
инициализируется как NULL, а переменная content_size инициализируется равным 0, 
даже если у параметра content_size другое значение. Переменная next 
инициализируется значением NULL. Если распределение завершается неудачно, 
функция возвращает NULL.*/

t_list				*ft_lstlast(t_list *lst);
/* добавляет лист в конец структуры */

t_list				*ft_lstmap(t_list *lst, void *(f)(void *),
						void (*del)(void *));
/* перебирает список lst и применяет функцию f к каждому листу, чтобы
 создать «свежий» список (используя malloc), полученный в результате 
 последовательного применения функции f. Если распределение завершается 
 неудачно, функция возвращает NULL.*/

void				ft_lstadd_front(t_list **lst, t_list *n);
/* Функция ft_lstadd добавляет лист new в начало листа lst*/

void				ft_lstadd_back(t_list **lst, t_list *n);
/* Функция ft_lstadd добавляет лист new в конец листа листа lst*/

void				ft_lstdelone(t_list *lst, void (*del)(void *));
/* удаляет лист из структуры */

void				ft_lstclear(t_list **lst, void (*del)(void *));
/* */

void				ft_lstiter(t_list *lst, void (*f)(void *));
/* применяет функцию f к каждому листу списка ls */

#endif
